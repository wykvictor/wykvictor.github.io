---
layout: post
title:  "OpenCV Basics - Mat"
date:   2016-12-28 16:00:00
tags: [opencv, Mat]
categories: CV
---

> 转自[OpenCV入门教程](http://blog.csdn.net/poem_qianmo/article/details/19925819)

#### 1. Mat - ROI Rect
{% highlight C++ %}
imageROI= image(Rect(800,350,logo.cols,logo.rows));  //使用矩形界定
// or 使用行和列界定
imageROI= image(Range(350,350+logo.rows),Range(800,800+logo.cols));
{% endhighlight %}
初始化
{% highlight C++ %}
Mat I = Mat::eye(4, 4, CV_64F);  // ones, zeros
I.at<double>(1,1) = CV_PI;  // 注意这么引用！

// 小矩阵可以这么写
Mat C = (Mat_<double>(3, 3) << 0, -1, 0, -1, 5, -1, 0, -1, 0);

Mat r = Mat(10, 3, CV_8UC3);
randu(r, Scalar::all(0), Scalar::all(255)); // 随机值填充，设定上下限
{% endhighlight %}
输出格式 format(r, Formatter::FMT_PYTHON)
{% highlight C++ %}
cout << "r (OpenCV默认风格) = " << r << ";" << endl << endl;
// Python风格 更清晰
cout << "r (Python风格) = " << format(r, Formatter::FMT_PYTHON) << ";" << endl << endl;
cout << "r (Numpy风格) = " <<  format(r, Formatter::FMT_NUMPY )<< ";" << endl << endl;
cout << "r (逗号分隔风格) = " << format(r, Formatter::FMT_CSV   )<< ";" << endl<< endl;
cout << "r (C语言风格) = " <<  format(r, Formatter::FMT_C     ) << ";" << endl << endl;
{% endhighlight %}

#### 2. Get Pixel in Mat
Use C style ptr
{% highlight C++ %}
void colorReduce(Mat& inputImage, Mat& outputImage, int div) {
  //参数准备
  outputImage = inputImage.clone();  //拷贝实参到临时变量
  int rowNumber = outputImage.rows;  //行数
  //列数 x 通道数=每一行元素的个数
  int colNumber = outputImage.cols * outputImage.channels();
  //双重循环，遍历所有的像素值
  for (int i = 0; i < rowNumber; i++) {
    uchar* data = outputImage.ptr<uchar>(i);  //获取第i行的首地址
    for (int j = 0; j < colNumber; j++) {
      // ---------【开始处理每个像素】-------------
      data[j] = data[j]/div*div + div/2;
      // !!! 或使用 *data++= *data/div*div + div/2
      // data[j] & mask 快4倍，mask = 0xFF << 6
		}
	}  
}  
{% endhighlight %}
Iterator, 更安全，不会指针越界，但需事先知道type Vec3b
{% highlight C++ %}
void colorReduce(Mat& inputImage, Mat& outputImage, int div) {
  //参数准备
  outputImage = inputImage.clone();  //拷贝实参到临时变量
  //获取迭代器
  Mat_<Vec3b>::iterator it = outputImage.begin<Vec3b>();  //初始位置的迭代器
  Mat_<Vec3b>::iterator itend = outputImage.end<Vec3b>();  //终止位置的迭代器
  //存取彩色图像像素
  for (; it != itend; ++it) {
    // -----------【开始处理每个像素】--------------------
    (*it)[0] = (*it)[0] / div * div + div / 2;
    (*it)[1] = (*it)[1] / div * div + div / 2;
    (*it)[2] = (*it)[2] / div * div + div / 2;
	}  
}
{% endhighlight %}
at方法，直观，但速度慢，也许知道事先类型 vec3b
{% highlight C++ %}
void colorReduce(Mat& inputImage, Mat& outputImage, int div) {
  //参数准备
  outputImage = inputImage.clone();  //拷贝实参到临时变量
  int rowNumber = outputImage.rows;  //行数
  int colNumber = outputImage.cols;  //列数
  //存取彩色图像像素
  for (int i = 0; i < rowNumber; i++) {
    for (int j = 0; j < colNumber; j++) {
      // ------------【开始处理每个像素】--------------------
      outputImage.at<Vec3b>(i, j)[0] =
          outputImage.at<Vec3b>(i, j)[0] / div * div + div / 2;  //蓝 通道
      outputImage.at<Vec3b>(i, j)[1] =
          outputImage.at<Vec3b>(i, j)[1] / div * div + div / 2;  //绿 通道
      outputImage.at<Vec3b>(i, j)[2] =
          outputImage.at<Vec3b>(i, j)[2] / div * div + div / 2;  //红 通道
    }  // 行处理结束     
	}  
}
{% endhighlight %}
