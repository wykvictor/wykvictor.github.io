---
layout: post
title:  "Cuda 2 - Parallel Algorithms(Reduce, Scan, Histogram, Sort)"
date:   2016-4-4 17:00:00
tags: [cuda, Algorithms, reduce, scan, histogram]
categories: Programming
---

> UDACITY教程 [Intro to Parallel Programming][link] 

> * Basics on GPU, CUDA, Memory Model
  * *Parallel Algorithms(Reduce, Scan, Histogram, Sort)*
  * Optimize Parallel GPU Programs
  * Others(Library, OpenACC, Dynamic parallelism)

[link]: https://www.udacity.com/wiki/cs344

### 1. Reduce
Input: 1) set of elements 2)reduction operator: binary(2 to 1), associative(- is not, + is)

Serial Implementation: work/step complexity O(n)

Parallel Impplementation: O(log2(n))
[Example](https://github.com/wykvictor/cs344-udacity/blob/master/Lesson%20Code%20Snippets/Lesson%203%20Code%20Snippets/reduce.cu)

### 2. Scan
Also need an "Identity element"(I op a = a)

统计该元素之前所有位置的op结果(不包括当前位置)

Parallel it: 1) logn steps and nlogn works 2) 2logn steps and 2n work

### 3. Histogram
1. 效率较低: Need to use atomic operation(Hash计数问题)
2. 优化: Reduced-based algorithm: Each thread has its own bin

### 4. Sort, then Reduce by Key

### 5. Problem 3
Image Tone-mapping:
[my-solution](https://github.com/wykvictor/cs344-udacity/blob/master/Problem%20Sets/Problem%20Set%203/student_func.cu)

### 6. Compact - filter
Use **Scan** to compute the Address of the density-array.

1. Sparse Matrix: - CSR representation
	
	![csr](http://7xno5y.com1.z0.glb.clouddn.com/matrix-csr.png)

2. Solution-1 - thread/element by Segmented Scan:
	
	![multi](http://7xno5y.com1.z0.glb.clouddn.com/csr-multi-2.png)

	* Use ROWPTR to generate segmented value array
	* Thread per element: map (VALUE[n] * X[COLUMN[n]])
	* Backwards inclusive segmented sum scan
	* Use ROWPTR to gather sparse output into dense vector

3. Solution-2 - thread/row cuda code:(similar # of elements/row, 3X faster)
	
	![csr-cuda](http://7xno5y.com1.z0.glb.clouddn.com/gpu-csr-cuda.png)

4. Solution-3 - Hybrid:

	![multi-3](http://7xno5y.com1.z0.glb.clouddn.com/csr-multi-3.png)

### 7. Sort
1. ODD_EVEN Sort(O(n), 类似冒泡排序)
2. Merge Sort(?)
3. Sorting Networks: 比较的顺序很tricky!
4. Radix Sort: GPU容易实现，且效率高
	![radix-sort](http://7xno5y.com1.z0.glb.clouddn.com/radix-sort-offical.jpg)

5. Quick Sort
6. [Parallel Prefix Sum (Scan)](http://http.developer.nvidia.com/GPUGems3/gpugems3_ch39.html)

### 8. Problem 4
Red Eye Removal:
[Parallel Radix Sort](https://github.com/wykvictor/cs344-udacity/blob/master/Problem%20Sets/Problem%20Set%204/student_func.cu)